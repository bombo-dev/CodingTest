# Sort Algorithm(정렬 알고리즘)

## 정렬
- 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
---

## 문제 유형
### 1. 정렬 라이브러리로 풀 수 있는 문제
- 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
### 2. 정렬 알고리즘의 원리에 대해서 물어보는 문제
- 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
### 3. 더 빠른 정렬이 필요한 문제
- 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.
---

### 선택 정렬(Selection sort)
- 데이터가 무작위로 여러 개 있을 때, **이 중에서 가장 작은 데이터를 선택**해 **맨 앞에 있는 데이터와 바꾸고**, 그 다음 **작은 데이터를 선택**해 **앞에서 n번째 데이터와 바꾸는 과정을 반복**하는 것
- 가장 원시적인 방법, **가장 작은 것을 선택**한다.
- 따라서, **가장 작은 데이터를 앞으로 보내는 과정은 N-1번 반복**하면 정렬이 완료된다.
- 시간 복잡도 : N + (N - 1) + (N - 2) + ... + 2 -> 근사치로 N(N + 1) / 2번의 연산을 수행한다.
- 따라서, 알고리즘 문제 풀이에 사용하기에는 느린 편이다.
### 즉, **O(N<sup>2</sup>)**

---
### 삽입 정렬(Insertion Sort)
- **데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입**하는 것
- 필요할 때만 위치를 바꾸므로 **데이터가 거의 정렬되어 있을 때 효율적**이다.
- 삽입 정렬은 기본적으로 **특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬**되어있다고 가정한다.
- 따라서 삽입 정렬은 두 번째 데이터부터 시작한다.
- **거의 정렬되어 있는 상태로 입력이 주어지는 문제는 퀵 정렬보다 빠르다.**

### 즉, **O(N<sup>2</sup>)**
### **&Omega;(N)** / 거의 정렬되어있는 상태 일때 

---
### 퀵 정렬(Quick Sort)
- 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘
- **기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 것**
- **큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식**
- 퀵 정렬에서는 피벗(Pivot)이 사용된다.
#### 피벗 : 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'
- 호어 분할(Hoare Partition) : 리스트에서 첫 번째 데이터를 피벗으로 정한다.
### 퀵 정렬 단계
1. 리스트의 첫 번째 데이터를 피벗으로 설정한다.
2. 이후 왼쪽에서부터 피벗보다 큰 데이터를 선택하고, 오른쪽에서부터 피벗보다 작은 데이터를 선택한다.
3. 두 데이터의 위치를 변경한다.
4. 다시 2 ~ 3번을 반복한다. 
5. 피벗을 기준으로 데이터 선택 과정중에 두 데이터 탐색 방향이 교차하면 작은 데이터와 피벗을 교체한다.
6. 피벗을 기준으로 왼쪽에는 작은 데이터, 오른쪽에는 큰 데이터가 위치하게 되는데, 이를 **분할(Divide)** 혹은 **파티션(Partition)** 이라고 한다.
7. 분할된 좌, 우의 리스트에서 1 ~ 6의 과정을 반복하고 리스트 내부의 데이터의 개수가 1일 때 그만 분할한다.

### 즉, **O(N<sup>2</sup>)** : 이미 데이터가 정렬되어 있을 때, **&theta;(NlogN)** 

---
### 계수 정렬(Count Sort)
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
- 조건 : 일반적으로 **가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때**
- 이유 : **'모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문'**
- 사용할 상황 : 동일한 값을 가지는 데이터가 여러 개 등장할 때, ex) 학생 성적
### 시간복잡도 O(N + K), N : 데이터의 개수, K : 데이터의 최댓값

---

## 퀵 정렬 VS 계수 정렬

### 1. 데이터의 특성을 파악하기 어렵다. --> 퀵 정렬
### 2. 데이터가 동일한 값을 가지는 데이터가 여러 개 등장한다. --> 계수 정렬

