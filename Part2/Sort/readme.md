# Sort Algorithm(정렬 알고리즘)

## 정렬
- 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
---

### 선택 정렬(Selection sort)
- 데이터가 무작위로 여러 개 있을 때, **이 중에서 가장 작은 데이터를 선택**해 **맨 앞에 있는 데이터와 바꾸고**, 그 다음 **작은 데이터를 선택**해 **앞에서 n번째 데이터와 바꾸는 과정을 반복**하는 것
- 가장 원시적인 방법, **가장 작은 것을 선택**한다.
- 따라서, **가장 작은 데이터를 앞으로 보내는 과정은 N-1번 반복**하면 정렬이 완료된다.
- 시간 복잡도 : N + (N - 1) + (N - 2) + ... + 2 -> 근사치로 N(N + 1) / 2번의 연산을 수행한다.
- 따라서, 알고리즘 문제 풀이에 사용하기에는 느린 편이다.
### 즉, **O(N<sup>2</sup>)**

---
### 삽입 정렬(Insertion Sort)
- **데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입**하는 것
- 필요할 때만 위치를 바꾸므로 **데이터가 거의 정렬되어 있을 때 효율적**이다.
- 삽입 정렬은 기본적으로 **특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬**되어있다고 가정한다.
- 따라서 삽입 정렬은 두 번째 데이터부터 시작한다.
- **거의 정렬되어 있는 상태로 입력이 주어지는 문제는 퀵 정렬보다 빠르다.**

### 즉, **O(N<sup>2</sup>)**
### **&Omega;(N)** / 거의 정렬되어있는 상태 일때 

---
### 퀵 정렬(Quick Sort)
- 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘
- **기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 것**
- **큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식**
- 퀵 정렬에서는 피벗(Pivot)이 사용된다.
#### 피벗 : 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'
- 호어 분할(Hoare Partition) : 리스트에서 첫 번째 데이터를 피벗으로 정한다.
### 퀵 정렬 단계
1. 리스트의 첫 번째 데이터를 피벗으로 설정한다.
2. 이후 왼쪽에서부터 피벗보다 큰 데이터를 선택하고, 오른쪽에서부터 피벗보다 작은 데이터를 선택한다.
3. 두 데이터의 위치를 변경한다.
4. 다시 2 ~ 3번을 반복한다. 
5. 피벗을 기준으로 데이터 선택 과정중에 두 데이터 탐색 방향이 교차하면 작은 데이터와 피벗을 교체한다.
6. 피벗을 기준으로 왼쪽에는 작은 데이터, 오른쪽에는 큰 데이터가 위치하게 되는데, 이를 **분할(Divide)** 혹은 **파티션(Partition)** 이라고 한다.
7. 분할된 좌, 우의 리스트에서 1 ~ 6의 과정을 반복하고 리스트 내부의 데이터의 개수가 1일 때 그만 분할한다.

### 즉, **O(N<sup>2</sup>)** : 이미 데이터가 정렬되어 있을 때, **&theta;(NlogN)** 


